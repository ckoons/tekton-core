#!/bin/bash
# tekton-launch - Unified script to launch all Tekton components in the correct order
# Created: April 11, 2025
# Updated: April 19, 2025 - Modified to use targeted port-specific process management

# ============================
# Port Assignments by Component
# ============================
# Hephaestus UI:       8080 (HTTP server), 8081 (WebSocket server)
# Engram:              8000 (Memory server)
# Hermes:              8100 (Service registry), 8101 (Database)
# Ergon:               8200 (Agent system)
# Other components may use additional ports as needed

# ANSI color codes for terminal output
BLUE="\033[94m"
GREEN="\033[92m"
YELLOW="\033[93m"
RED="\033[91m"
BOLD="\033[1m"
RESET="\033[0m"

# Find Tekton root directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
if [[ "$SCRIPT_DIR" == *"/utils" ]]; then
    # Script is running from a symlink in utils
    TEKTON_DIR=$(cd "$SCRIPT_DIR" && cd "$(readlink "${BASH_SOURCE[0]}" | xargs dirname | xargs dirname)" && pwd)
else
    # Script is running from Tekton/scripts
    TEKTON_DIR="$( cd "$SCRIPT_DIR/.." && pwd )"
fi

# Ensure we're in the correct directory context
cd "$TEKTON_DIR"

# We'll conditionally source the tekton-kill script only if we're launching Hermes
LAUNCHING_HERMES=false

# Function to check if we're launching Hermes (called after parsing arguments)
check_if_launching_hermes() {
    # Check if launch-all is specified
    if [ "$LAUNCH_ALL" = true ]; then
        LAUNCHING_HERMES=true
        return
    fi

    # Check if "hermes" or "all" is in the components list
    for comp in "${COMPONENTS[@]}"; do
        if [ "$comp" = "hermes" ] || [ "$comp" = "all" ]; then
            LAUNCHING_HERMES=true
            return
        fi
    done
}

# The sourcing and port check will be done after processing arguments
# This placeholder will be replaced with the actual call in the main execution

# Default values
MODEL_TYPE="claude" 
MODEL="claude-3-sonnet-20240229"
CLIENT_ID="tekton"
LAUNCH_UI=true
LAUNCH_ALL=false
INTERACTIVE=true
COMPONENTS=()
DEFAULT_COMPONENTS=("engram" "hermes")

# Save the original working directory
ORIGINAL_DIR="$(pwd)"

# Component directories
HEPHAESTUS_DIR="${TEKTON_DIR}/Hephaestus"
ENGRAM_DIR="${TEKTON_DIR}/Engram"
HERMES_DIR="${TEKTON_DIR}/Hermes"
ERGON_DIR="${TEKTON_DIR}/Ergon"
RHETOR_DIR="${TEKTON_DIR}/Rhetor"
ATHENA_DIR="${TEKTON_DIR}/Athena"
PROMETHEUS_DIR="${TEKTON_DIR}/Prometheus"
HARMONIA_DIR="${TEKTON_DIR}/Harmonia"
SOPHIA_DIR="${TEKTON_DIR}/Sophia"
TELOS_DIR="${TEKTON_DIR}/Telos"
SYNTHESIS_DIR="${TEKTON_DIR}/Synthesis"

# Function to display usage information
show_usage() {
    echo "Tekton - Unified launcher for all Tekton components"
    echo ""
    echo "Usage: tekton-launch [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --components COMP        Comma-separated list of components to launch:"
    echo "                           all: All available components"
    echo "                           Individual: engram,hermes,ergon,rhetor,athena,prometheus,"
    echo "                                       harmonia,sophia,telos,hephaestus"
    echo "  --launch-all             Launch all available components (equivalent to --components all)"
    echo "  --model-type TYPE        Type of model to launch: claude, ollama (default: claude)"
    echo "  --model MODEL            Specific model to use (defaults depend on model type)"
    echo "  --client-id ID           Client ID for Engram (default: tekton)"
    echo "  --no-ui                  Don't launch the Hephaestus UI"
    echo "  --non-interactive        Run in non-interactive mode (use defaults for unspecified options)"
    echo "  --help                   Show this help message"
    echo ""
    echo "Examples:"
    echo "  Launch all components:                 tekton-launch --launch-all"
    echo "  Launch selected components:            tekton-launch --components engram,hermes,ergon"
    echo "  Launch with Ollama and custom model:   tekton-launch --model-type ollama --model llama3"
}

# Function to check if a process is running
is_running() {
    pgrep -f "$1" >/dev/null
    return $?
}

# Function to check if a port is in use
is_port_used() {
    lsof -ti :"$1" >/dev/null 2>&1
    return $?
}

# Function to release a specific port by killing the process using it
# This is a simplified version of the function in tekton_kill
release_component_port() {
    local port="$1"
    local description="$2"
    
    if is_port_used "$port"; then
        echo -e "${YELLOW}Port $port ($description) is in use - releasing it...${RESET}"
        local PIDS=$(lsof -ti :"$port" 2>/dev/null)
        
        if [ -n "$PIDS" ]; then
            echo -e "${YELLOW}Killing process (PID: $PIDS) using port $port...${RESET}"
            
            # Try graceful shutdown first
            kill $PIDS 2>/dev/null || true
            sleep 1
            
            # Check if still in use
            if is_port_used "$port"; then
                echo -e "${YELLOW}Port $port still in use, using SIGKILL...${RESET}"
                kill -9 $(lsof -ti :"$port" 2>/dev/null) 2>/dev/null || true
            fi
            
            sleep 1
            if is_port_used "$port"; then
                echo -e "${RED}Warning: Port $port could not be released${RESET}"
                return 1
            else
                echo -e "${GREEN}✓ Port $port successfully released${RESET}"
                return 0
            fi
        fi
    else
        echo -e "${GREEN}Port $port is already free${RESET}"
        return 0
    fi
}

# Function to prompt user for input with default value
prompt_with_default() {
    local prompt="$1"
    local default="$2"
    local options="$3"
    local response
    
    # If options are provided, show them
    if [ -n "$options" ]; then
        prompt="$prompt ($options)"
    fi
    
    # Show prompt with default
    echo -en "${YELLOW}$prompt ${RESET}[${GREEN}$default${RESET}]: "
    read -r response
    
    # Return user input or default if empty
    echo "${response:-$default}"
}

# Function to prompt for yes/no with default
prompt_yes_no() {
    local prompt="$1"
    local default="$2"
    local response
    
    # Prepare default indicator
    if [ "$default" = "y" ]; then
        local options="Y/n"
    else
        local options="y/N"
    fi
    
    # Show prompt with default
    echo -en "${YELLOW}$prompt ${RESET}[$options]: "
    read -r response
    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
    
    # Return true (0) for yes, false (1) for no
    if [ -z "$response" ]; then
        [ "$default" = "y" ]
        return $?
    else
        [ "$response" = "y" ] || [ "$response" = "yes" ]
        return $?
    fi
}

# Function to detect and list available components
detect_components() {
    echo -e "${BLUE}Detecting Tekton components...${RESET}"
    
    local components=()
    
    # Check for Synthesis
    if [ -d "$SYNTHESIS_DIR" ] && [ -f "$SYNTHESIS_DIR/synthesis/core/execution_engine.py" ]; then
        components+=("synthesis")
        echo -e "${GREEN}✓ Synthesis (Execution Engine)${RESET}"
    else
        echo -e "${YELLOW}⚠ Synthesis not found or incomplete${RESET}"
    fi
    
    # Check for Hephaestus
    if [ -d "$HEPHAESTUS_DIR" ] && [ -f "$HEPHAESTUS_DIR/hephaestus/ui/main.py" ]; then
        components+=("hephaestus")
        echo -e "${GREEN}✓ Hephaestus (UI System)${RESET}"
    else
        echo -e "${RED}✗ Hephaestus not found or incomplete${RESET}"
    fi
    
    # Check for Engram
    if [ -d "$ENGRAM_DIR" ] && [ -f "$ENGRAM_DIR/core/engram_consolidated" ]; then
        components+=("engram")
        echo -e "${GREEN}✓ Engram (Memory System)${RESET}"
    else
        echo -e "${RED}✗ Engram not found or incomplete${RESET}"
    fi
    
    # Check for Hermes
    if [ -d "$HERMES_DIR" ] && [ -f "$HERMES_DIR/hermes/core/service_discovery.py" ]; then
        components+=("hermes")
        echo -e "${GREEN}✓ Hermes (Database & Messaging)${RESET}"
    else
        echo -e "${YELLOW}⚠ Hermes not found or incomplete${RESET}"
    fi
    
    # Check for Ergon
    if [ -d "$ERGON_DIR" ]; then
        if [ -d "$ERGON_DIR/ergon" ] && [ -f "$ERGON_DIR/ergon/__init__.py" ]; then
            components+=("ergon")
            echo -e "${GREEN}✓ Ergon (Agent System)${RESET}"
        else
            echo -e "${YELLOW}⚠ Ergon found but not fully implemented${RESET}"
        fi
    fi
    
    # Check for Rhetor
    if [ -d "$RHETOR_DIR" ]; then
        if [ -d "$RHETOR_DIR/rhetor" ] && [ -f "$RHETOR_DIR/rhetor/__init__.py" ]; then
            components+=("rhetor")
            echo -e "${GREEN}✓ Rhetor (Communication)${RESET}"
        else
            echo -e "${YELLOW}⚠ Rhetor found but not fully implemented${RESET}"
        fi
    fi
    
    # Check for Telos
    if [ -d "$TELOS_DIR" ]; then
        if [ -d "$TELOS_DIR/telos" ] && [ -f "$TELOS_DIR/telos/__init__.py" ]; then
            components+=("telos")
            echo -e "${GREEN}✓ Telos (User Interface)${RESET}"
        else
            echo -e "${YELLOW}⚠ Telos found but not fully implemented${RESET}"
        fi
    fi
    
    # Check for Prometheus
    if [ -d "$PROMETHEUS_DIR" ] && [ -f "$PROMETHEUS_DIR/prometheus/core/planning_engine.py" ]; then
        components+=("prometheus")
        echo -e "${GREEN}✓ Prometheus (Planning)${RESET}"
    else
        echo -e "${YELLOW}⚠ Prometheus not found or incomplete${RESET}"
    fi
    
    # Check for Harmonia
    if [ -d "$HARMONIA_DIR" ]; then
        if [ -d "$HARMONIA_DIR/harmonia" ] && [ -f "$HARMONIA_DIR/harmonia/core/workflow.py" ]; then
            components+=("harmonia")
            echo -e "${GREEN}✓ Harmonia (Workflow)${RESET}"
        else
            echo -e "${YELLOW}⚠ Harmonia found but not fully implemented${RESET}"
        fi
    fi
    
    # Check for Athena
    if [ -d "$ATHENA_DIR" ]; then
        if [ -d "$ATHENA_DIR/athena" ] && [ -f "$ATHENA_DIR/athena/core/entity.py" ]; then
            components+=("athena")
            echo -e "${GREEN}✓ Athena (Knowledge Graph)${RESET}"
        else
            echo -e "${YELLOW}⚠ Athena found but not fully implemented${RESET}"
        fi
    fi
    
    # Check for Sophia
    if [ -d "$SOPHIA_DIR" ]; then
        if [ -d "$SOPHIA_DIR/sophia" ] && [ -f "$SOPHIA_DIR/sophia/core/ml_engine.py" ]; then
            components+=("sophia")
            echo -e "${GREEN}✓ Sophia (Machine Learning)${RESET}"
        else
            echo -e "${YELLOW}⚠ Sophia found but not fully implemented${RESET}"
        fi
    fi
    
    # Return the list of components
    echo "${components[@]}"
}

# Interactive component selection
select_components() {
    local all_components=("$@")
    local selected_components=()
    
    echo -e "${BLUE}${BOLD}Select components to launch:${RESET}"
    
    # Ask about Hephaestus (UI)
    if [[ " ${all_components[*]} " == *" hephaestus "* ]]; then
        if prompt_yes_no "Launch Hephaestus (UI System)?" "y"; then
            selected_components+=("hephaestus")
        fi
    fi
    
    # Ask about Engram (Memory)
    if [[ " ${all_components[*]} " == *" engram "* ]]; then
        if prompt_yes_no "Launch Engram (Memory System)?" "y"; then
            selected_components+=("engram")
        fi
    fi
    
    # Ask about Hermes (Database)
    if [[ " ${all_components[*]} " == *" hermes "* ]]; then
        if prompt_yes_no "Launch Hermes (Database & Messaging)?" "y"; then
            selected_components+=("hermes")
        fi
    fi
    
    # Ask about Ergon (Agents)
    if [[ " ${all_components[*]} " == *" ergon "* ]]; then
        if prompt_yes_no "Launch Ergon (Agent System)?" "y"; then
            selected_components+=("ergon")
        fi
    fi
    
    # Ask about Rhetor (Communication)
    if [[ " ${all_components[*]} " == *" rhetor "* ]]; then
        if prompt_yes_no "Launch Rhetor (Communication)?" "n"; then
            selected_components+=("rhetor")
        fi
    fi
    
    # Ask about Telos (User Interface)
    if [[ " ${all_components[*]} " == *" telos "* ]]; then
        if prompt_yes_no "Launch Telos (User Interface)?" "n"; then
            selected_components+=("telos")
        fi
    fi
    
    # Ask about Prometheus (Planning)
    if [[ " ${all_components[*]} " == *" prometheus "* ]]; then
        if prompt_yes_no "Launch Prometheus (Planning)?" "n"; then
            selected_components+=("prometheus")
        fi
    fi
    
    # Ask about Harmonia (Workflow)
    if [[ " ${all_components[*]} " == *" harmonia "* ]]; then
        if prompt_yes_no "Launch Harmonia (Workflow)?" "n"; then
            selected_components+=("harmonia")
        fi
    fi
    
    # Ask about Athena (Knowledge Graph)
    if [[ " ${all_components[*]} " == *" athena "* ]]; then
        if prompt_yes_no "Launch Athena (Knowledge Graph)?" "n"; then
            selected_components+=("athena")
        fi
    fi
    
    # Ask about Sophia (Machine Learning)
    if [[ " ${all_components[*]} " == *" sophia "* ]]; then
        if prompt_yes_no "Launch Sophia (Machine Learning)?" "n"; then
            selected_components+=("sophia")
        fi
    fi
    
    # Ask about Synthesis (Execution Engine)
    if [[ " ${all_components[*]} " == *" synthesis "* ]]; then
        if prompt_yes_no "Launch Synthesis (Execution Engine)?" "n"; then
            selected_components+=("synthesis")
        fi
    fi
    
    echo "${selected_components[@]}"
}

# Launch Hephaestus UI
launch_hephaestus() {
    echo -e "${BLUE}${BOLD}Launching Hephaestus UI...${RESET}"
    
    # Check if Hephaestus is already running
    if is_running "Hephaestus/ui/server/server.py"; then
        echo -e "${GREEN}Hephaestus UI is already running${RESET}"
        return 0
    fi
    
    # No build step needed
    
    # Launch Hephaestus UI directly
    if [ -x "$HEPHAESTUS_DIR/run_ui.sh" ]; then
        echo -e "${BLUE}Using run_ui.sh script...${RESET}"
        
        # Verify ports are free before launching
        echo -e "${YELLOW}Checking if Hephaestus ports are available...${RESET}"
        
        # Use targeted port management - only release the specific ports needed by this component
        # If Hermes is launching, the full tekton_kill script will handle this
        if [ "$LAUNCHING_HERMES" = false ]; then
            # Release HTTP port if it's in use
            release_component_port "8080" "Hephaestus HTTP"
            HTTP_PORT_RESULT=$?
            
            # Release WebSocket port if it's in use
            release_component_port "8081" "Hephaestus WebSocket"
            WS_PORT_RESULT=$?
            
            # Verify ports are now free
            if [ $HTTP_PORT_RESULT -ne 0 ] || [ $WS_PORT_RESULT -ne 0 ]; then
                echo -e "${RED}Error: Ports 8080 or 8081 could not be released. Cannot start Hephaestus UI.${RESET}"
                echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
                return 1
            fi
        fi
        
        # By this point the ports should be available - either through tekton_kill or release_component_port
        echo -e "${GREEN}Ports are available. Proceeding with launch.${RESET}"
        
        # Set up Python path
        export PYTHONPATH="$TEKTON_DIR:$PYTHONPATH"
        
        # Create logs directory
        mkdir -p "$HOME/.tekton/logs"
        
        # Launch the UI server
        (cd "$HEPHAESTUS_DIR" && "./run_ui.sh" --port 8080 > "$HOME/.tekton/logs/hephaestus.log" 2>&1) &
        HEPHAESTUS_PID=$!
        
        # Wait briefly to see if it crashed
        sleep 3
        if ps -p $HEPHAESTUS_PID > /dev/null; then
            echo -e "${GREEN}✓ Hephaestus UI started successfully${RESET}"
            echo -e "${GREEN}  Access the UI at: http://localhost:8080${RESET}"
            return 0
        else
            echo -e "${RED}✗ Hephaestus UI failed to start${RESET}"
            cat "$HOME/.tekton/logs/hephaestus.log"
            return 1
        fi
    else
        echo -e "${RED}✗ No Hephaestus launch script found${RESET}"
        return 1
    fi
}

# Launch Engram component
launch_engram() {
    echo -e "${BLUE}${BOLD}Launching Engram Memory System...${RESET}"
    
    # Check if Engram memory service is already running
    if is_running "engram.api.consolidated_server"; then
        echo -e "${GREEN}Engram memory service is already running${RESET}"
        return 0
    fi
    
    # Verify port is free before launching
    echo -e "${YELLOW}Checking if Engram port 8000 is available...${RESET}"
    
    # Use targeted port management - only release the specific port needed by this component
    # If Hermes is launching, the full tekton_kill script will handle this
    if [ "$LAUNCHING_HERMES" = false ]; then
        # Release the port if it's in use
        release_component_port "8000" "Engram Memory"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Port 8000 could not be released. Cannot start Engram Memory Service.${RESET}"
            echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
            return 1
        fi
    fi
    
    # By this point the port should be available - either through tekton_kill or release_component_port
    echo -e "${GREEN}Port 8000 is available. Proceeding with launch.${RESET}"
    
    # Find the consolidated server script
    ENGRAM_STARTUP="$ENGRAM_DIR/core/engram_consolidated"
    
    # Double-check the directory structure
    if [ ! -d "$ENGRAM_DIR" ]; then
        echo -e "${RED}Error: Engram directory not found at $ENGRAM_DIR${RESET}"
        echo -e "${YELLOW}Make sure you're running this script from the Tekton directory${RESET}"
        return 1
    fi
    
    # Check if the Python module contains the necessary files
    if [ ! -d "$ENGRAM_DIR/engram" ]; then
        echo -e "${YELLOW}Warning: Engram Python module directory not found${RESET}"
    fi
    
    # Check if the startup script exists
    if [ -x "$ENGRAM_STARTUP" ]; then
        echo -e "${GREEN}Found Engram startup script at: $ENGRAM_STARTUP${RESET}"
        
        # Create data directory
        mkdir -p "$HOME/.tekton/data"
        mkdir -p "$HOME/.tekton/logs"
        
        # First check if Engram is in the Python path
        python3 -c "import engram" 2>/dev/null
        if [ $? -ne 0 ]; then
            echo -e "${YELLOW}Adding Engram to Python path...${RESET}"
            export PYTHONPATH="$ENGRAM_DIR:$PYTHONPATH"
            
            # Install Engram package if needed
            if [ -f "$ENGRAM_DIR/setup.py" ]; then
                echo -e "${YELLOW}Installing Engram package...${RESET}"
                (cd "$ENGRAM_DIR" && pip install -e . --quiet)
            fi
        fi
        
        # Force fallback mode to avoid vector database issues
        export ENGRAM_USE_FALLBACK=1
        echo -e "${YELLOW}Setting ENGRAM_USE_FALLBACK=1 to use file-based storage${RESET}"
        
        # Start the service
        (cd "$TEKTON_DIR" && "$ENGRAM_STARTUP" --fallback --data-dir "$HOME/.tekton/data" > "$HOME/.tekton/logs/engram.log" 2>&1) &
        ENGRAM_PID=$!
        
        echo -e "${GREEN}Started Engram memory service with PID: $ENGRAM_PID${RESET}"
        
        # Wait for service to be ready
        echo -e "${BLUE}Waiting for Engram service to be ready...${RESET}"
        for i in {1..30}; do  # Extended timeout (60 seconds)
            sleep 2  # 2 second sleep
            if ! ps -p $ENGRAM_PID > /dev/null; then
                echo -e "${RED}Memory service failed to start${RESET}"
                echo -e "${RED}Engram log:${RESET}"
                cat "$HOME/.tekton/logs/engram.log"
                return 1
            fi
            
            # Try connecting to health endpoint (silent curl)
            if curl -s "http://127.0.0.1:8000/health" > /dev/null 2>&1; then
                echo -e "${GREEN}Engram memory service is online!${RESET}"
                return 0
            fi
            
            echo -n "."
        done
        
        echo ""
        echo -e "${YELLOW}Engram service may not be fully ready, but continuing...${RESET}"
        return 0
    else
        echo -e "${RED}Engram consolidated server script not found at $ENGRAM_STARTUP${RESET}"
        echo -e "${YELLOW}Checking for alternative script locations...${RESET}"
        
        # Check for alternative script locations
        local ALTERNATIVE_PATHS=(
            "$ENGRAM_DIR/engram_consolidated"
            "$ENGRAM_DIR/scripts/engram_consolidated"
            "$ENGRAM_DIR/bin/engram_consolidated"
        )
        
        for alt_path in "${ALTERNATIVE_PATHS[@]}"; do
            if [ -x "$alt_path" ]; then
                echo -e "${GREEN}Found alternative Engram script at: $alt_path${RESET}"
                ENGRAM_STARTUP="$alt_path"
                # Re-run this function with the updated path
                launch_engram
                return $?
            fi
        done
        
        echo -e "${RED}No Engram startup script found in alternative locations${RESET}"
        echo -e "${YELLOW}Available files in Engram directory:${RESET}"
        find "$ENGRAM_DIR" -type f -name "*engram*" -perm -u+x | head -5
        return 1
    fi
}

# Launch Hermes component
launch_hermes() {
    echo -e "${BLUE}${BOLD}Launching Hermes Database & Messaging as Lifecycle Manager...${RESET}"
    
    # Check if Hermes is already running
    if is_running "hermes.*database_manager"; then
        echo -e "${GREEN}Hermes services are already running${RESET}"
        return 0
    fi
    
    # Verify ports are free before launching
    echo -e "${YELLOW}Checking if Hermes ports are available...${RESET}"
    
    # For Hermes, we use the full tekton_kill script which has already been sourced
    # If not sourced, something went wrong as LAUNCHING_HERMES should be true here
    if type release_port >/dev/null 2>&1; then
        # Release Hermes ports using the common function from tekton_kill
        release_port "8100" "Hermes Service Registry"
        SERVICE_REGISTRY_PORT_RESULT=$?
        
        release_port "8101" "Hermes Database"
        DATABASE_PORT_RESULT=$?
        
        # Verify ports are now free
        if [ $SERVICE_REGISTRY_PORT_RESULT -ne 0 ] || [ $DATABASE_PORT_RESULT -ne 0 ]; then
            echo -e "${RED}Error: Hermes ports still in use. Cannot start Hermes services.${RESET}"
            echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
            return 1
        else
            echo -e "${GREEN}Ports are available. Proceeding with launch.${RESET}"
        fi
    else
        # Fallback if the release_port function is not available
        # This should not happen if LAUNCHING_HERMES is true
        echo -e "${YELLOW}Warning: Using fallback port checking for Hermes${RESET}"
        
        # Release the Service Registry port if it's in use
        release_component_port "8100" "Hermes Service Registry"
        SERVICE_REGISTRY_PORT_RESULT=$?
        
        # Release the Database port if it's in use
        release_component_port "8101" "Hermes Database"
        DATABASE_PORT_RESULT=$?
        
        # Verify ports are now free
        if [ $SERVICE_REGISTRY_PORT_RESULT -ne 0 ] || [ $DATABASE_PORT_RESULT -ne 0 ]; then
            echo -e "${RED}Error: Hermes ports could not be released. Cannot start Hermes services.${RESET}"
            echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
            return 1
        else
            echo -e "${GREEN}Ports are available. Proceeding with launch.${RESET}"
        fi
    fi
    
    # Set up Python path
    export PYTHONPATH="$HERMES_DIR:$PYTHONPATH"
    
    # Create data directory
    mkdir -p "$HOME/.tekton/data/hermes"
    
    # Create log directories
    mkdir -p "$HOME/.tekton/logs"

    # Prepare environment variables for Python script
    HERMES_PY_DIR="$HERMES_DIR"
    HOME_PY_DIR="$HOME"
    COMPONENT_MGMT="true"  # Enable component lifecycle management
    
    # Launch the Hermes API server with enhanced lifecycle management
    python3 -c "
import sys, os, subprocess, asyncio
sys.path.insert(0, '$HERMES_DIR')

# Set environment variables for the API server
env = os.environ.copy()
env['PORT'] = '8100'  # API server port
env['HOST'] = '127.0.0.1'
env['HERMES_DATA_DIR'] = '$HOME_PY_DIR/.tekton/data/hermes'
env['DB_MCP_PORT'] = '8101'  # Database MCP port
env['DB_MCP_HOST'] = '127.0.0.1'
env['HERMES_COMPONENT_MANAGER'] = 'true'  # Enable component lifecycle management
env['HERMES_AUTO_LAUNCH'] = 'true'  # Enable auto-launching of registered components

# Find the API script
api_path = os.path.join('$HERMES_DIR', 'hermes', 'api', 'app.py')

if os.path.exists(api_path):
    # Start the Hermes API server in a separate process
    api_process = subprocess.Popen(
        [sys.executable, api_path],
        env=env,
        stdout=open('$HOME_PY_DIR/.tekton/logs/hermes_api.log', 'w'),
        stderr=open('$HOME_PY_DIR/.tekton/logs/hermes_api.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Hermes API server started successfully in lifecycle management mode${RESET}')
else:
    # Fallback to separate components if API server script not found
    print('${YELLOW}Hermes API server script not found, falling back to separate components${RESET}')
    
    # Start database manager in a separate process
    subprocess.Popen(
        [sys.executable, '-c', '''
import sys, asyncio, os
sys.path.insert(0, \"$HERMES_PY_DIR\")
from hermes.core.database.manager import DatabaseManager

async def run():
    os.makedirs(\"$HOME_PY_DIR/.tekton/data/hermes\", exist_ok=True)
    # Create a database manager instance
    db_manager = DatabaseManager(
        base_path=\"$HOME_PY_DIR/.tekton/data/hermes\",
        config={\"log_level\": \"INFO\", \"port\": 8101}  # Explicitly set Hermes Database port
    )
    
    # Create a simple initialization function for the database
    async def init_database():
        print(\"Database manager created with base_path: \" + str(db_manager.base_path))
        
        # Log that the database manager is initialized but don't try to create connections
        # This avoids errors when adapter implementations are not available
        print(\"Database manager initialized - ready to accept connections\")
        
        # INTEGRATION TEST NOTE: The following code was originally intended to test database 
        # connections during startup. It was commented out because other Tekton components 
        # are responsible for managing these connections. This should be revisited during 
        # integration testing when the full Tekton stack is available.
        #
        # During integration testing, verify these connections:
        # 1. Vector database (FAISS/Qdrant) - for embeddings and similarity search
        # 2. Key-value database - for configuration and lightweight storage
        # 3. Document database - for structured data storage
        # 4. Graph database - for knowledge representation 
        #
        # try:
        #     # Try to access each database type to confirm initialization
        #     await db_manager.get_vector_db(namespace=\"test\")
        #     await db_manager.get_key_value_db(namespace=\"test\")
        #     await db_manager.get_document_db(namespace=\"test\")
        #     await db_manager.get_graph_db(namespace=\"test\")
        #     print(\"Database manager fully initialized with all connections\")
        # except Exception as e:
        #     print(f\"Warning: Error initializing database connections: {e}\")
        #     print(\"Continuing anyway as core services should still work\")
        
        # Return without trying to create connections that might fail
        return
    
    # Initialize the database
    await init_database()
    
    # Keep the service running
    while True:
        await asyncio.sleep(1)

asyncio.run(run())
'''],
        stdout=open(\"$HOME_PY_DIR/.tekton/logs/hermes_db.log\", 'w'),
        stderr=open(\"$HOME_PY_DIR/.tekton/logs/hermes_db.log\", 'w'),
        close_fds=True
    )

    # Start enhanced service registry with lifecycle management in a separate process
    subprocess.Popen(
        [sys.executable, '-c', '''
import sys, asyncio, os
sys.path.insert(0, \"$HERMES_PY_DIR\")
from hermes.core.service_discovery import ServiceRegistry

async def run():
    # Create registry with component lifecycle management
    enable_lifecycle = os.environ.get('HERMES_COMPONENT_MANAGER', 'false').lower() == 'true'
    auto_launch = os.environ.get('HERMES_AUTO_LAUNCH', 'false').lower() == 'true'
    
    registry = ServiceRegistry(
        check_interval=30, 
        timeout=10,
        enable_lifecycle_management=enable_lifecycle,
        auto_launch_components=auto_launch
    )
    
    # The start method is synchronous, not async
    registry.start()
    print(f\"Service registry started with lifecycle management: {enable_lifecycle}, auto-launch: {auto_launch}\")
    
    while True:
        await asyncio.sleep(1)

asyncio.run(run())
'''],
        stdout=open(\"$HOME_PY_DIR/.tekton/logs/hermes_registry.log\", 'w'),
        stderr=open(\"$HOME_PY_DIR/.tekton/logs/hermes_registry.log\", 'w'),
        close_fds=True
    )
    
    print('${GREEN}Hermes services started successfully with lifecycle management${RESET}')
" &
    
    # Give services time to start
    sleep 2
    
    # Check if Python processes with 'hermes' in the command line are running
    # Wait a bit longer to let processes start
    sleep 5
    
    # First check if the API server is running
    if pgrep -f "hermes/api/app.py" > /dev/null; then
        echo -e "${GREEN}Hermes API server is running${RESET}"
        API_RUNNING=true
        
        # Try to verify the API is responding
        if curl -s "http://localhost:8100/api/health" > /dev/null 2>&1; then
            echo -e "${GREEN}Hermes API is responding to health checks${RESET}"
            echo -e "${GREEN}Hermes is now ready to manage component lifecycle${RESET}"
        else
            echo -e "${YELLOW}Hermes API processes are running but not responding yet${RESET}"
        fi
        
        # If the API is running, we're good to go
        echo -e "${GREEN}Hermes services started successfully${RESET}"
        return 0
    else
        echo -e "${YELLOW}Hermes API server not running, checking individual components${RESET}"
        API_RUNNING=false
    fi
    
    # Fall back to checking individual components
    # Check for database manager process
    if pgrep -f "hermes.*database.manager" > /dev/null; then
        echo -e "${GREEN}Hermes Database Manager is running${RESET}"
        DB_RUNNING=true
    else
        echo -e "${RED}Hermes Database Manager did not start correctly${RESET}"
        DB_RUNNING=false
    fi
    
    # Check for service registry process
    if pgrep -f "hermes.*service_discovery" > /dev/null; then
        echo -e "${GREEN}Hermes Service Registry is running${RESET}"
        SR_RUNNING=true
    else
        echo -e "${RED}Hermes Service Registry did not start correctly${RESET}"
        SR_RUNNING=false
    fi
    
    # Return success if at least one component is running
    if [ "$DB_RUNNING" = true ] || [ "$SR_RUNNING" = true ]; then
        echo -e "${GREEN}Hermes services started successfully${RESET}"
        return 0
    else
        echo -e "${RED}Failed to start any Hermes services${RESET}"
        echo -e "${YELLOW}Checking logs...${RESET}"
        
        # Check API logs first if available
        if [ -f "$HOME/.tekton/logs/hermes_api.log" ]; then
            echo -e "${YELLOW}Hermes API log:${RESET}"
            cat "$HOME/.tekton/logs/hermes_api.log"
        fi
        
        # Then check individual component logs
        cat "$HOME/.tekton/logs/hermes_db.log" 2>/dev/null || echo "No database log available"
        cat "$HOME/.tekton/logs/hermes_registry.log" 2>/dev/null || echo "No registry log available"
        
        return 1
    fi
}

# Launch Ergon component
launch_ergon() {
    echo -e "${BLUE}${BOLD}Launching Ergon Agent System...${RESET}"
    
    # Check if Ergon is already running
    if is_running "ergon.core"; then
        echo -e "${GREEN}Ergon services are already running${RESET}"
        return 0
    fi
    
    # Verify port is free before launching
    echo -e "${YELLOW}Checking if Ergon port 8200 is available...${RESET}"
    
    # Use targeted port management - only release the specific port needed by this component
    # If Hermes is launching, the full tekton_kill script will handle this
    if [ "$LAUNCHING_HERMES" = false ]; then
        # Release the port if it's in use
        release_component_port "8200" "Ergon Agent System"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Port 8200 could not be released. Cannot start Ergon Agent System.${RESET}"
            echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
            return 1
        fi
    fi
    
    # By this point the port should be available - either through tekton_kill or release_component_port
    echo -e "${GREEN}Port 8200 is available. Proceeding with launch.${RESET}"
    
    # Check if Ergon is implemented
    if [ -d "$ERGON_DIR/ergon" ] && [ -f "$ERGON_DIR/ergon/__init__.py" ]; then
        # Set up Python path
        export PYTHONPATH="$ERGON_DIR:$PYTHONPATH"
        
        # Launch Ergon server
        python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$ERGON_DIR')

try:
    # Start Ergon server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', '''
import sys, asyncio
sys.path.insert(0, sys.argv[1])
import os

try:
    # Try to import the API app
    from ergon.api.app import app
    import uvicorn
    
    # Run the server
    uvicorn.run(app, host='127.0.0.1', port=8200)
except ImportError as e:
    print(f'Error importing Ergon modules: {e}')
except Exception as e:
    print(f'Error running Ergon server: {e}')
''', '$ERGON_DIR'],
        stdout=open(os.path.expanduser('$HOME/.tekton/logs/ergon.log'), 'w'),
        stderr=open(os.path.expanduser('$HOME/.tekton/logs/ergon.log'), 'w'),
        close_fds=True
    )
    print('${GREEN}Ergon server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Ergon server: {e}${RESET}')
" &
        
        # Give services time to start
        sleep 2
        
        echo -e "${GREEN}Ergon agent system initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Ergon component is not yet fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Ergon launch${RESET}"
        return 0
    fi
}

# Launch Rhetor component
launch_rhetor() {
    echo -e "${BLUE}${BOLD}Launching Rhetor Communication System...${RESET}"
    
    # Check if Rhetor is already running
    if is_running "rhetor.core"; then
        echo -e "${GREEN}Rhetor services are already running${RESET}"
        return 0
    fi
    
    # Check if Rhetor is implemented
    if [ -d "$RHETOR_DIR/rhetor" ] && [ -f "$RHETOR_DIR/rhetor/__init__.py" ]; then
        # Set up Python path
        export PYTHONPATH="$RHETOR_DIR:$PYTHONPATH"
        
        # Launch Rhetor server if the startup module exists
        if [ -f "$RHETOR_DIR/rhetor/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$RHETOR_DIR')

try:
    # Start Rhetor server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{RHETOR_DIR}')
from rhetor.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/rhetor.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/rhetor.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Rhetor server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Rhetor server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Rhetor communication system initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Rhetor component is not yet fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Rhetor launch${RESET}"
        return 0
    fi
}

# Launch Prometheus component
launch_prometheus() {
    echo -e "${BLUE}${BOLD}Launching Prometheus Planning System...${RESET}"
    
    # Check if Prometheus is already running
    if is_running "prometheus.core"; then
        echo -e "${GREEN}Prometheus services are already running${RESET}"
        return 0
    fi
    
    # Check if Prometheus is implemented
    if [ -d "$PROMETHEUS_DIR/prometheus" ] && [ -f "$PROMETHEUS_DIR/prometheus/core/planning_engine.py" ]; then
        # Set up Python path
        export PYTHONPATH="$PROMETHEUS_DIR:$PYTHONPATH"
        
        # Launch Prometheus if server module exists
        if [ -f "$PROMETHEUS_DIR/prometheus/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$PROMETHEUS_DIR')

try:
    # Start Prometheus server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{PROMETHEUS_DIR}')
from prometheus.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/prometheus.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/prometheus.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Prometheus server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Prometheus server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Prometheus planning system initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Prometheus planning engine is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Prometheus launch${RESET}"
        return 0
    fi
}

# Launch Harmonia component
launch_harmonia() {
    echo -e "${BLUE}${BOLD}Launching Harmonia Workflow System...${RESET}"
    
    # Check if Harmonia is already running
    if is_running "harmonia.core"; then
        echo -e "${GREEN}Harmonia services are already running${RESET}"
        return 0
    fi
    
    # Check if Harmonia is implemented
    if [ -d "$HARMONIA_DIR/harmonia" ] && [ -f "$HARMONIA_DIR/harmonia/core/workflow.py" ]; then
        # Set up Python path
        export PYTHONPATH="$HARMONIA_DIR:$PYTHONPATH"
        
        # Launch Harmonia if server module exists
        if [ -f "$HARMONIA_DIR/harmonia/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$HARMONIA_DIR')

try:
    # Start Harmonia server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{HARMONIA_DIR}')
from harmonia.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/harmonia.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/harmonia.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Harmonia server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Harmonia server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Harmonia workflow system initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Harmonia workflow engine is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Harmonia launch${RESET}"
        return 0
    fi
}

# Launch Athena component
launch_athena() {
    echo -e "${BLUE}${BOLD}Launching Athena Knowledge Graph...${RESET}"
    
    # Check if Athena is already running
    if is_running "athena.core"; then
        echo -e "${GREEN}Athena services are already running${RESET}"
        return 0
    fi
    
    # Check if Athena is implemented
    if [ -d "$ATHENA_DIR/athena" ] && [ -f "$ATHENA_DIR/athena/core/entity.py" ]; then
        # Set up Python path
        export PYTHONPATH="$ATHENA_DIR:$PYTHONPATH"
        
        # Launch Athena if server module exists
        if [ -f "$ATHENA_DIR/athena/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$ATHENA_DIR')

try:
    # Start Athena server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{ATHENA_DIR}')
from athena.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/athena.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/athena.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Athena server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Athena server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Athena knowledge graph initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Athena knowledge graph is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Athena launch${RESET}"
        return 0
    fi
}

# Launch Sophia component
launch_sophia() {
    echo -e "${BLUE}${BOLD}Launching Sophia Machine Learning System...${RESET}"
    
    # Check if Sophia is already running
    if is_running "sophia.core"; then
        echo -e "${GREEN}Sophia services are already running${RESET}"
        return 0
    fi
    
    # Check if Sophia is implemented
    if [ -d "$SOPHIA_DIR/sophia" ] && [ -f "$SOPHIA_DIR/sophia/core/ml_engine.py" ]; then
        # Set up Python path
        export PYTHONPATH="$SOPHIA_DIR:$PYTHONPATH"
        
        # Launch Sophia if server module exists
        if [ -f "$SOPHIA_DIR/sophia/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$SOPHIA_DIR')

try:
    # Start Sophia server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{SOPHIA_DIR}')
from sophia.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/sophia.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/sophia.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Sophia server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Sophia server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Sophia machine learning system initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Sophia machine learning system is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Sophia launch${RESET}"
        return 0
    fi
}

# Launch Synthesis component
launch_synthesis() {
    echo -e "${BLUE}${BOLD}Launching Synthesis Execution Engine...${RESET}"
    
    # Check if Synthesis is already running
    if is_running "synthesis.core"; then
        echo -e "${GREEN}Synthesis services are already running${RESET}"
        return 0
    fi
    
    # Verify port is free before launching
    echo -e "${YELLOW}Checking if Synthesis port 5005 is available...${RESET}"
    
    # Use targeted port management - only release the specific port needed by this component
    # If Hermes is launching, the full tekton_kill script will handle this
    if [ "$LAUNCHING_HERMES" = false ]; then
        # Release the port if it's in use
        release_component_port "5005" "Synthesis Engine"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Port 5005 could not be released. Cannot start Synthesis Execution Engine.${RESET}"
            echo -e "${YELLOW}Try running tekton-kill first to clear all processes.${RESET}"
            return 1
        fi
    fi
    
    # By this point the port should be available - either through tekton_kill or release_component_port
    echo -e "${GREEN}Port 5005 is available. Proceeding with launch.${RESET}"
    
    # Check if Synthesis is implemented
    if [ -d "$SYNTHESIS_DIR/synthesis" ] && [ -f "$SYNTHESIS_DIR/synthesis/core/execution_engine.py" ]; then
        # Set up Python path
        export PYTHONPATH="$SYNTHESIS_DIR:$PYTHONPATH"
        
        # Create log directory if it doesn't exist
        mkdir -p "$HOME/.tekton/logs"
        
        # Create a server script file to avoid triple-quote issues
        SCRIPT_FILE="$HOME/.tekton/synthesis_server.py"
        
        # Check if the script file already exists - if it does, don't overwrite it
        if [ -f "$SCRIPT_FILE" ]; then
            echo -e "${GREEN}Using existing Synthesis server script...${RESET}"
        else
            echo -e "${YELLOW}Creating new Synthesis server script...${RESET}"
            # Write server script to a file with proper event loop handling
            cat > "$SCRIPT_FILE" << 'EOFPYTHON'
import sys, asyncio, os
import logging
import threading
import signal

# Get Synthesis directory from argument
synthesis_dir = sys.argv[1]
sys.path.insert(0, synthesis_dir)

# Configure logging
log_dir = os.path.expanduser("~/.tekton/logs")
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, "synthesis.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(log_file)
    ]
)
logger = logging.getLogger("synthesis")

# Flag to signal shutdown
shutdown_event = asyncio.Event()

async def register_with_hermes():
    """Register Synthesis with Hermes service registry."""
    try:
        from synthesis.scripts.register_with_hermes import register_with_hermes
        hermes_url = os.environ.get("HERMES_URL", "http://localhost:8100/api")
        logger.info(f"Registering with Hermes at {hermes_url}")
        
        # Register and get result
        result = await register_with_hermes(hermes_url=hermes_url)
        if result:
            logger.info("Successfully registered with Hermes")
        else:
            logger.warning("Failed to register with Hermes, but continuing")
    except Exception as e:
        logger.warning(f"Failed to register with Hermes: {e}")

async def start_fastapi_server(host="127.0.0.1", port=5005):
    """Start the FastAPI server with uvicorn without using asyncio.run()."""
    try:
        # Import FastAPI and uvicorn
        from fastapi import FastAPI
        import uvicorn
        from uvicorn.config import Config
        from uvicorn.server import Server
        
        # Import execution engine
        from synthesis.core.execution_engine import ExecutionEngine
        from synthesis.core.phase_manager import PhaseManager
        
        # Create FastAPI app
        app = FastAPI(title="Synthesis API", description="Execution Engine API")
        
        # Initialize components
        engine = ExecutionEngine()
        phase_manager = PhaseManager()
        
        # Add routes
        @app.get("/")
        async def root():
            return {"status": "ok", "service": "Synthesis Execution Engine"}
            
        @app.get("/health")
        async def health():
            return {"status": "healthy"}
        
        # Configure uvicorn
        config = Config(app=app, host=host, port=port, log_level="info")
        server = Server(config=config)
        
        # Start server directly (avoiding asyncio.run())
        logger.info(f"Starting Synthesis API server on {host}:{port}")
        await server.serve()
        
        return server
    except ImportError:
        # Fallback to a simple server
        logger.warning("FastAPI not available, using simple HTTP server")
        
        # Create a simple HTTP server in a separate thread
        from http.server import HTTPServer, BaseHTTPRequestHandler
        import json
        import threading
        
        class SynthesisHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                if self.path == "/" or self.path == "/health":
                    self.send_response(200)
                    self.send_header("Content-type", "application/json")
                    self.end_headers()
                    response = {"status": "ok", "service": "Synthesis Execution Engine"}
                    self.wfile.write(json.dumps(response).encode())
                else:
                    self.send_response(404)
                    self.end_headers()
        
        def run_http_server():
            server = HTTPServer((host, port), SynthesisHandler)
            logger.info(f"Starting simple HTTP server on {host}:{port}")
            
            # Allow keyboard interrupt to stop the server
            def handler(signum, frame):
                logger.info("Shutting down HTTP server")
                server.shutdown()
            
            signal.signal(signal.SIGINT, handler)
            signal.signal(signal.SIGTERM, handler)
            
            server.serve_forever()
        
        # Start the HTTP server in a separate thread
        server_thread = threading.Thread(target=run_http_server)
        server_thread.daemon = True
        server_thread.start()
        
        # Wait for shutdown signal
        while not shutdown_event.is_set():
            await asyncio.sleep(1)
            
    except Exception as e:
        logger.error(f"Error starting Synthesis execution engine: {e}")
        raise

async def main():
    """Main entry point for the Synthesis server."""
    try:
        # Register with Hermes first
        await register_with_hermes()
        
        # Initialize engine components
        logger.info("Initializing Synthesis execution engine")
        from synthesis.core.execution_engine import ExecutionEngine
        engine = ExecutionEngine()
        logger.info("Synthesis Execution Engine initialized (max concurrent: 5)")
        
        # Start the API server
        logger.info("Starting Synthesis API on 127.0.0.1:5005")
        await start_fastapi_server(host="127.0.0.1", port=5005)
        
    except Exception as e:
        logger.error(f"Error starting Synthesis: {e}")
        raise

# Setup signal handlers
def signal_handler():
    loop = asyncio.get_event_loop()
    loop.stop()
    logger.info("Synthesis server shutdown complete")

# Start the main loop
if __name__ == "__main__":
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Set up signal handlers
        for sig in (signal.SIGINT, signal.SIGTERM):
            loop.add_signal_handler(sig, signal_handler)
        
        # Run the main coroutine
        loop.create_task(main())
        loop.run_forever()
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received, shutting down")
    except Exception as e:
        logger.error(f"Error in main loop: {e}")
    finally:
        logger.info("Closing event loop")
        loop.close()
EOFPYTHON
        fi
        
        # Make the script executable
        chmod +x "$SCRIPT_FILE"
        
        # Launch the Synthesis server script
        echo -e "${YELLOW}Starting Synthesis server script...${RESET}"
        python3 "$SCRIPT_FILE" "$SYNTHESIS_DIR" > "$HOME/.tekton/logs/synthesis.log" 2>&1 &
        SYNTHESIS_PID=$!
        
        echo -e "${GREEN}Synthesis server started with PID: $SYNTHESIS_PID${RESET}"
        
        # Wait a moment for the server to start
        sleep 3
        
        # Check if process is still running
        if ! ps -p $SYNTHESIS_PID > /dev/null; then
            echo -e "${RED}Synthesis server failed to start${RESET}"
            cat "$HOME/.tekton/logs/synthesis.log"
            echo -e "${YELLOW}Continuing despite Synthesis startup failure${RESET}"
        else
            echo -e "${GREEN}Synthesis execution engine started successfully${RESET}"
        fi
        
        # Give services time to start
        sleep 3
        
        # Verify the service is running
        if curl -s http://localhost:5005/health > /dev/null 2>&1; then
            echo -e "${GREEN}Synthesis API is responding on port 5005${RESET}"
        else
            echo -e "${YELLOW}Synthesis API may not be fully ready, but continuing...${RESET}"
        fi
        
        echo -e "${GREEN}Synthesis execution engine initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Synthesis execution engine is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Synthesis launch${RESET}"
        return 0
    fi
}

# Launch Telos component
launch_telos() {
    echo -e "${BLUE}${BOLD}Launching Telos User Interface...${RESET}"
    
    # Check if Telos is already running
    if is_running "telos.core"; then
        echo -e "${GREEN}Telos services are already running${RESET}"
        return 0
    fi
    
    # Check if Telos is implemented
    if [ -d "$TELOS_DIR/telos" ] && [ -f "$TELOS_DIR/telos/__init__.py" ]; then
        # Set up Python path
        export PYTHONPATH="$TELOS_DIR:$PYTHONPATH"
        
        # Launch Telos if server module exists
        if [ -f "$TELOS_DIR/telos/core/server.py" ]; then
            python3 -c "
import sys, os, subprocess
sys.path.insert(0, '$TELOS_DIR')

try:
    # Start Telos server in a separate process
    subprocess.Popen(
        [sys.executable, '-c', f'''
import sys, asyncio
sys.path.insert(0, '{TELOS_DIR}')
from telos.core.server import start_server
import os

async def run():
    await start_server()

asyncio.run(run())
'''],
        stdout=open(f'{HOME}/.tekton/logs/telos.log', 'w'),
        stderr=open(f'{HOME}/.tekton/logs/telos.log', 'w'),
        close_fds=True
    )
    print('${GREEN}Telos server started successfully${RESET}')
except Exception as e:
    print(f'${RED}Error starting Telos server: {e}${RESET}')
" &
            
            # Give services time to start
            sleep 2
        fi
        
        echo -e "${GREEN}Telos user interface initialized${RESET}"
        return 0
    else
        echo -e "${YELLOW}Telos user interface is not fully implemented${RESET}"
        echo -e "${YELLOW}Skipping Telos launch${RESET}"
        return 0
    fi
}

# Launch AI model (Claude or Ollama)
launch_ai_model() {
    echo -e "${BLUE}${BOLD}Launching $MODEL_TYPE model: $MODEL${RESET}"
    
    case "$MODEL_TYPE" in
        "claude")
            # Check if model is available
            if [ "$MODEL" = "claude-3-sonnet-20240229" ] || [ "$MODEL" = "claude-3-opus-20240229" ] || [ "$MODEL" = "claude-3-5-sonnet" ]; then
                echo -e "${GREEN}Using Claude model: $MODEL${RESET}"
            else
                echo -e "${YELLOW}Requested model '$MODEL' may not be available, attempting to use anyway${RESET}"
            fi
            
            # Set model via env var
            export ANTHROPIC_API_MODEL="$MODEL"
            
            # Check if Claude CLI is installed
            if command -v claude &> /dev/null; then
                # Launch Claude
                echo -e "${GREEN}Starting Claude with model: $MODEL${RESET}"
                echo -e "${YELLOW}To exit Claude, press Ctrl+D${RESET}"
                echo -e "${BLUE}-----------------------------------------------${RESET}"
                claude --allowedTools='Bash(*),Edit,View,Replace,BatchTool,GlobTool,GrepTool,LS,ReadNotebook,NotebookEditCell,WebFetchTool'
            else
                echo -e "${RED}Claude CLI not found in PATH${RESET}"
                echo -e "${YELLOW}To install Claude CLI, follow instructions at:${RESET}"
                echo -e "${YELLOW}https://github.com/anthropics/anthropic-cli${RESET}"
                return 1
            fi
            ;;
            
        "ollama")
            # Check if Ollama is running
            if ! curl -s http://localhost:11434/api/tags > /dev/null; then
                echo -e "${RED}Error: Ollama is not running. Please start Ollama first.${RESET}"
                return 1
            fi
            
            # Find the Ollama bridge script
            OLLAMA_BRIDGE="$ENGRAM_DIR/ollama/ollama_bridge.py"
            
            # Verify the bridge file exists
            if [ ! -f "$OLLAMA_BRIDGE" ]; then
                echo -e "${RED}Error: Ollama bridge script not found at $OLLAMA_BRIDGE${RESET}"
                
                # Check for alternative locations
                ALT_BRIDGES=(
                    "$ENGRAM_DIR/ollama/bridge/ollama_bridge.py"
                    "$ENGRAM_DIR/bridge/ollama_bridge.py"
                )
                
                for alt_bridge in "${ALT_BRIDGES[@]}"; do
                    if [ -f "$alt_bridge" ]; then
                        echo -e "${GREEN}Found alternative Ollama bridge at: $alt_bridge${RESET}"
                        OLLAMA_BRIDGE="$alt_bridge"
                        break
                    fi
                done
                
                if [ ! -f "$OLLAMA_BRIDGE" ]; then
                    echo -e "${RED}No Ollama bridge script found in alternative locations${RESET}"
                    return 1
                fi
            fi
            
            # Add paths to PYTHONPATH
            export PYTHONPATH="$ENGRAM_DIR/ollama:$ENGRAM_DIR:$PYTHONPATH"
            
            # Build command
            CMD="python3 $OLLAMA_BRIDGE $MODEL --prompt-type combined --client-id $CLIENT_ID --temperature 0.7 --max-tokens 2048 --memory-functions"
            
            # Execute the command
            echo -e "${GREEN}Starting Ollama with model: $MODEL${RESET}"
            $CMD
            ;;
            
        *)
            echo -e "${RED}Unknown model type: $MODEL_TYPE${RESET}"
            echo -e "${YELLOW}Supported model types: claude, ollama${RESET}"
            return 1
            ;;
    esac
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --components)
      IFS=',' read -r -a COMPONENTS <<< "$2"
      shift 2
      ;;
    --launch-all)
      LAUNCH_ALL=true
      shift
      ;;
    --model-type)
      MODEL_TYPE="$2"
      shift 2
      ;;
    --model)
      MODEL="$2"
      shift 2
      ;;
    --client-id)
      CLIENT_ID="$2"
      shift 2
      ;;
    --no-ui)
      LAUNCH_UI=false
      shift
      ;;
    --non-interactive)
      INTERACTIVE=false
      shift
      ;;
    --help)
      show_usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      echo "Try 'tekton-launch --help' for more information."
      exit 1
      ;;
  esac
done

# Display banner
echo -e "${BLUE}${BOLD}====== Tekton Orchestration System ======${RESET}"
echo -e "${GREEN}Tekton installation: $TEKTON_DIR${RESET}"
echo ""

# Create necessary directories
mkdir -p "$HOME/.tekton/data"
mkdir -p "$HOME/.tekton/logs"
echo -e "${GREEN}Ensured data directories exist in $HOME/.tekton${RESET}"

# Check if we're launching Hermes after parsing all arguments
check_if_launching_hermes

# Only source the kill script and clean up if we're launching Hermes
if [ "$LAUNCHING_HERMES" = true ]; then
    echo -e "${YELLOW}Hermes will be launched - cleaning up existing environment...${RESET}"
    # Source the tekton-kill script to use its functions
    if [ -f "$SCRIPT_DIR/tekton-kill" ]; then
        source "$SCRIPT_DIR/tekton-kill"
    elif [ -f "$TEKTON_DIR/scripts/tekton-kill" ]; then
        source "$TEKTON_DIR/scripts/tekton-kill"
    else
        echo -e "${RED}Error: Could not find tekton-kill script${RESET}"
        exit 1
    fi
    
    # Clean up any existing components and ensure ports are available
    echo -e "${BLUE}${BOLD}Ensuring a clean environment before launch...${RESET}"
    ensure_ports_available
    if [ $? -ne 0 ]; then
        echo -e "${YELLOW}Warning: Could not free all required ports. Attempting to continue...${RESET}"
    fi
    echo ""
else
    echo -e "${GREEN}Hermes is not being launched - preserving existing environment${RESET}"
    echo -e "${YELLOW}Note: Some ports may already be in use by other Tekton components${RESET}"
    echo ""
fi

# Detect available components
AVAILABLE_COMPONENTS=($(detect_components))

# If launch-all is specified, set all available components
if [ "$LAUNCH_ALL" = true ]; then
    COMPONENTS=("${AVAILABLE_COMPONENTS[@]}")
    echo -e "${GREEN}Launch-all option specified. All available components will be launched.${RESET}"
    
    # Always ensure hermes is first in the list when launching all
    if [[ " ${COMPONENTS[*]} " == *" hermes "* ]]; then
        # Remove hermes from its current position
        NEW_COMPONENTS=()
        for comp in "${COMPONENTS[@]}"; do
            if [ "$comp" != "hermes" ]; then
                NEW_COMPONENTS+=("$comp")
            fi
        done
        # Add hermes as the first component
        COMPONENTS=("hermes" "${NEW_COMPONENTS[@]}")
    fi
    
# If no components specified, check if we're in interactive mode
elif [ ${#COMPONENTS[@]} -eq 0 ]; then
    if [ "$INTERACTIVE" = true ]; then
        # Ask user to select components
        COMPONENTS=($(select_components "${AVAILABLE_COMPONENTS[@]}"))
    else
        # Use default components in non-interactive mode
        COMPONENTS=("${DEFAULT_COMPONENTS[@]}")
    fi
fi

# Special case for "all" in components list
if [[ " ${COMPONENTS[*]} " == *" all "* ]]; then
    COMPONENTS=("${AVAILABLE_COMPONENTS[@]}")
    LAUNCH_ALL=true
    
    # Always ensure hermes is first in the list when launching all
    if [[ " ${COMPONENTS[*]} " == *" hermes "* ]]; then
        # Remove hermes from its current position
        NEW_COMPONENTS=()
        for comp in "${COMPONENTS[@]}"; do
            if [ "$comp" != "hermes" ]; then
                NEW_COMPONENTS+=("$comp")
            fi
        done
        # Add hermes as the first component
        COMPONENTS=("hermes" "${NEW_COMPONENTS[@]}")
    fi
fi

# If UI is explicitly disabled, remove hephaestus from components
if [ "$LAUNCH_UI" = false ]; then
    NEW_COMPONENTS=()
    for comp in "${COMPONENTS[@]}"; do
        if [ "$comp" != "hephaestus" ]; then
            NEW_COMPONENTS+=("$comp")
        fi
    done
    COMPONENTS=("${NEW_COMPONENTS[@]}")
fi

# If we're launching all components and UI is not explicitly disabled, ensure hephaestus is in the list
if [ "$LAUNCH_ALL" = true ] && [ "$LAUNCH_UI" = true ]; then
    if [[ ! " ${COMPONENTS[*]} " == *" hephaestus "* ]]; then
        COMPONENTS+=("hephaestus")
    fi
fi

# Display selected components
echo -e "${BLUE}${BOLD}Components to launch:${RESET}"
for comp in "${COMPONENTS[@]}"; do
    echo -e "${GREEN}• $comp${RESET}"
done
echo ""

# Launch components in the correct dependency order
# Always launch Hermes first if it's in the components list as it will manage other components
HERMES_LAUNCHED=false
OTHER_COMPONENTS=()

# First check if Hermes is in the component list
for comp in "${COMPONENTS[@]}"; do
    if [ "$comp" = "hermes" ]; then
        echo -e "${BLUE}${BOLD}Launching Hermes first as lifecycle manager...${RESET}"
        launch_hermes
        if [ $? -eq 0 ]; then
            HERMES_LAUNCHED=true
            # Give Hermes time to initialize before launching other components
            echo -e "${YELLOW}Waiting for Hermes to fully initialize...${RESET}"
            sleep 5
        else
            echo -e "${RED}Hermes failed to launch. Components may not be properly managed.${RESET}"
        fi
    else
        OTHER_COMPONENTS+=("$comp")
    fi
done

# If Hermes is launched, register other components with it
if [ "$HERMES_LAUNCHED" = true ]; then
    echo -e "${BLUE}${BOLD}Hermes will manage component lifecycle for:${RESET}"
    for comp in "${OTHER_COMPONENTS[@]}"; do
        echo -e "${GREEN}• $comp${RESET}"
    done
    echo ""
fi

# First: core infrastructure (Engram)
for comp in "${OTHER_COMPONENTS[@]}"; do
    if [ "$comp" = "engram" ]; then
        launch_engram
    fi
done

# Second: mid-level components (Ergon, Rhetor, Prometheus, Harmonia)
for comp in "${OTHER_COMPONENTS[@]}"; do
    if [ "$comp" = "ergon" ]; then
        launch_ergon
    elif [ "$comp" = "rhetor" ]; then
        launch_rhetor
    elif [ "$comp" = "prometheus" ]; then
        launch_prometheus
    elif [ "$comp" = "harmonia" ]; then
        launch_harmonia
    fi
done

# Third: high-level components (Athena, Sophia, Telos, Synthesis)
for comp in "${OTHER_COMPONENTS[@]}"; do
    if [ "$comp" = "athena" ]; then
        launch_athena
    elif [ "$comp" = "sophia" ]; then
        launch_sophia
    elif [ "$comp" = "telos" ]; then
        launch_telos
    elif [ "$comp" = "synthesis" ]; then
        launch_synthesis
    fi
done

# Finally: UI component (Hephaestus)
# Always ask about Hephaestus, even if not explicitly selected
if [[ " ${COMPONENTS[*]} " != *" hephaestus "* ]]; then
    if [ "$INTERACTIVE" = true ]; then
        if prompt_yes_no "Launch Hephaestus UI?" "y"; then
            COMPONENTS+=("hephaestus")
        fi
    fi
fi

# Launch Hephaestus if it's in the component list
for comp in "${COMPONENTS[@]}"; do
    if [ "$comp" = "hephaestus" ]; then
        launch_hephaestus
    fi
done

# Ask the user if they want to launch an AI model
if [ "$INTERACTIVE" = true ]; then
    if prompt_yes_no "Would you like to launch an AI model?" "y"; then
        # Ask about model type
        # Store model type in a clean variable to prevent interpretation issues
        model_type_response=$(prompt_with_default "Which AI model type would you like to use?" "$MODEL_TYPE" "claude, ollama")
        MODEL_TYPE=$(echo "$model_type_response" | tr -d '[:space:]')
        
        # Ask about specific model
        case "$MODEL_TYPE" in
            "claude")
                MODEL=$(prompt_with_default "Which Claude model would you like to use?" "$MODEL" "claude-3-sonnet-20240229, claude-3-opus-20240229, claude-3-5-sonnet")
                ;;
            "ollama")
                # Try to list available Ollama models
                if curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
                    MODELS=$(curl -s http://localhost:11434/api/tags | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    models = data.get('models', [])
    print(', '.join([model.get('name') for model in models]))
except:
    print('llama3, mistral, gemma')
")
                    MODEL=$(prompt_with_default "Which Ollama model would you like to use?" "llama3" "$MODELS")
                else
                    echo -e "${YELLOW}Ollama doesn't appear to be running. Please start it first.${RESET}"
                    MODEL=$(prompt_with_default "Which Ollama model would you like to use?" "llama3" "llama3, mistral, gemma")
                fi
                ;;
            *)
                echo -e "${RED}Unknown model type: '$MODEL_TYPE'${RESET}"
                echo -e "${YELLOW}Defaulting to Claude${RESET}"
                MODEL_TYPE="claude"
                MODEL="claude-3-sonnet-20240229"
                ;;
        esac
        
        # Launch the selected AI model
        launch_ai_model
    fi
fi

echo ""
echo -e "${GREEN}${BOLD}Tekton components launched successfully!${RESET}"

if [[ " ${COMPONENTS[*]} " == *" hephaestus "* ]]; then
    echo -e "${GREEN}Tekton UI is available at: http://localhost:8080${RESET}"
fi

echo -e "${YELLOW}To stop all Tekton components, run: ./scripts/tekton-kill${RESET}"